import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Put,
  UseInterceptors,
  HttpException,
  HttpStatus,
} from "@nestjs/common";
import { ApiTags, ApiConsumes, ApiBody, ApiOperation, ApiResponse } from "@nestjs/swagger";
import { JobOrderService } from "./job-order.service";
import { CreateJobOrderDto } from "./dto/create-job-order.dto";
import { UpdateJobOrderDto } from "./dto/update-job-order.dto";
import { MyFileRequestInterceptor } from "@shared/util/req.interceptor";
import { FileUtil } from "@shared/util/fileutil.helpers";
import { UploadType } from "@shared/util/file-validator.util";
import { Roles } from "@shared/decorators/roles.decorator";

@ApiTags("Job Order")
@Controller("job-order")
export class JobOrderController {
  constructor(
    private readonly jobOrderService: JobOrderService,
    private readonly fileUtil: FileUtil
  ) {}

  @Roles('Admin', 'HR Manager', 'Recruiter', 'Client Manager', 'Delivery Manager', 'Business Head', 'Finance Manager')
  @Post()
  @ApiConsumes("multipart/form-data")
  @ApiBody({
    schema: {
      type: "object",
      properties: {
        jobId: { type: "string" },
        clientName: { type: "string" },
        clientType: { type: "string" },
        jobTitle: { type: "string" },
        jobDescriptionSummary: { type: "string" },
        workLocationCountry: { type: "string" },
        remoteHybridOnsite: { type: "string" },
        jobStartDate: { type: "string", format: "date" },
        jobEndDate: { type: "string", format: "date" },
        contractType: { type: "string" },
        numberOfPositions: { type: "number" },
        requiredSkills: { type: "string" },
        yearsOfExperience: { type: "string" },
        minEducationalQualification: { type: "string" },
        salaryCtcRange: { type: "string" },
        shift: { type: "string" },
        shiftTiming: { type: "string" },
        languageRequirement: { type: "string" },
        languageProficiencyLevel: { type: "string" },
        nationalityPreference: { type: "string" },
        visaWorkPermitProvided: { type: "string" },
        clientSpocName: { type: "string" },
        internalRecruiterAssigned: { type: "string" },
        remarksNotes: { type: "string" },
        jobOwner: { type: "string" },
        deliveryLead: { type: "string" },
        status: { type: "string" },
        createdBy: { type: "string" },
        file: {
          type: "string",
          format: "binary",
        },
      },
    },
  })
  @UseInterceptors(
    new MyFileRequestInterceptor({
      numericFields: ["numberOfPositions"],
      dateFields: ["jobStartDate", "jobEndDate"],
      fileFieldName: "file",
      isMultiple: false,
    })
  )
  async create(@Body() payload: { data: any; fileDetails: any }) {
    try {
      let attachmentPath: string | undefined;

      // Handle file upload if present
      if (payload.fileDetails && payload.fileDetails.file) {
        try {
          const fileBData = payload.fileDetails.file;
          const uploadedFilePath = await this.fileUtil.saveFile(fileBData, UploadType.JOB_ORDER);
          if (uploadedFilePath) {
            attachmentPath = String(uploadedFilePath);
          }
        } catch (error) {
          console.error("Error uploading file:", error);
          // Continue without file if upload fails (S3 credentials issue)
          // You can uncomment the line below to make file upload required
          // throw new HttpException("Failed to upload file: " + error.message, HttpStatus.INTERNAL_SERVER_ERROR);
        }
      }

      const createJobOrderDto: CreateJobOrderDto = {
        // jobId will be generated by service, don't include it
        clientName: payload.data.clientName,
        clientType: payload.data.clientType,
        jobTitle: payload.data.jobTitle,
        jobDescriptionSummary: payload.data.jobDescriptionSummary,
        workLocationCountry: payload.data.workLocationCountry,
        remoteHybridOnsite: payload.data.remoteHybridOnsite,
        jobStartDate: payload.data.jobStartDate,
        jobEndDate: payload.data.jobEndDate,
        contractType: payload.data.contractType,
        numberOfPositions: parseInt(payload.data.numberOfPositions),
        requiredSkills: payload.data.requiredSkills,
        yearsOfExperience: payload.data.yearsOfExperience,
        minEducationalQualification: payload.data.minEducationalQualification,
        salaryCtcRange: payload.data.salaryCtcRange,
        shift: payload.data.shift,
        shiftTiming: payload.data.shiftTiming,
        languageRequirement: payload.data.languageRequirement,
        languageProficiencyLevel: payload.data.languageProficiencyLevel,
        nationalityPreference: payload.data.nationalityPreference,
        visaWorkPermitProvided: payload.data.visaWorkPermitProvided,
        clientSpocName: payload.data.clientSpocName,
        internalRecruiterAssigned: payload.data.internalRecruiterAssigned,
        remarksNotes: payload.data.remarksNotes,
        detailedJdAttachment: attachmentPath,
        jobOwner: payload.data.jobOwner,
        deliveryLead: payload.data.deliveryLead,
        status: payload.data.status || "Open",
        createdBy: payload.data.createdBy,
      };

      return await this.jobOrderService.create(createJobOrderDto, attachmentPath);
    } catch (error) {
      throw new HttpException(
        error.message || "Failed to create job order",
        error.status || HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Roles('Admin', 'HR Manager', 'Recruiter', 'Client Manager', 'Delivery Manager', 'Business Head', 'Finance Manager')
  @Get("next-job-id")
  @ApiOperation({ summary: "Get the next sequential Job ID" })
  @ApiResponse({ status: 200, description: "Next Job ID that will be assigned" })
  async getNextJobId() {
    const nextJobId = await this.jobOrderService.generateNextJobId();
    return { jobId: nextJobId };
  }

  @Roles('Admin', 'HR Manager', 'Recruiter', 'Client Manager', 'Delivery Manager', 'Business Head', 'Finance Manager')
  @Get()
  @ApiOperation({ summary: "Get all job orders" })
  @ApiResponse({ status: 200, description: "List of all job orders" })
  findAll() {
    return this.jobOrderService.findAll();
  }

  @Roles('Admin', 'HR Manager', 'Recruiter', 'Client Manager', 'Delivery Manager', 'Business Head', 'Finance Manager')
  @Get(":id/statistics")
  @ApiOperation({ summary: "Get candidate statistics for a job order" })
  @ApiResponse({ status: 200, description: "Candidate statistics by status" })
  @ApiResponse({ status: 404, description: "Job order not found" })
  async getStatistics(@Param("id") id: string) {
    return this.jobOrderService.getCandidateStatistics(id);
  }

  @Roles('Admin', 'HR Manager', 'Recruiter', 'Client Manager', 'Delivery Manager', 'Business Head', 'Finance Manager')
  @Get(":id")
  @ApiOperation({ summary: "Get a job order by ID" })
  @ApiResponse({ status: 200, description: "The job order with the given ID" })
  @ApiResponse({ status: 404, description: "Job order not found" })
  findOne(@Param("id") id: string) {
    return this.jobOrderService.findOne(id);
  }

  @Roles('Admin', 'HR Manager', 'Recruiter', 'Client Manager', 'Delivery Manager', 'Business Head', 'Finance Manager')
  @Put(":id")
  @ApiConsumes("multipart/form-data")
  @ApiBody({
    schema: {
      type: "object",
      properties: {
        jobId: { type: "string" },
        clientName: { type: "string" },
        clientType: { type: "string" },
        jobTitle: { type: "string" },
        jobDescriptionSummary: { type: "string" },
        workLocationCountry: { type: "string" },
        remoteHybridOnsite: { type: "string" },
        jobStartDate: { type: "string", format: "date" },
        jobEndDate: { type: "string", format: "date" },
        contractType: { type: "string" },
        numberOfPositions: { type: "number" },
        requiredSkills: { type: "string" },
        yearsOfExperience: { type: "string" },
        minEducationalQualification: { type: "string" },
        salaryCtcRange: { type: "string" },
        shift: { type: "string" },
        shiftTiming: { type: "string" },
        languageRequirement: { type: "string" },
        languageProficiencyLevel: { type: "string" },
        nationalityPreference: { type: "string" },
        visaWorkPermitProvided: { type: "string" },
        clientSpocName: { type: "string" },
        internalRecruiterAssigned: { type: "string" },
        remarksNotes: { type: "string" },
        jobOwner: { type: "string" },
        deliveryLead: { type: "string" },
        status: { type: "string" },
        updatedBy: { type: "string" },
        file: {
          type: "string",
          format: "binary",
        },
      },
    },
  })
  @UseInterceptors(
    new MyFileRequestInterceptor({
      numericFields: ["numberOfPositions"],
      dateFields: ["jobStartDate", "jobEndDate"],
      fileFieldName: "file",
      isMultiple: false,
    })
  )
  async update(
    @Param("id") id: string,
    @Body() payload: { data: any; fileDetails: any }
  ) {
    try {
      let attachmentPath: string | undefined;

      // Handle file upload if present
      if (payload.fileDetails && payload.fileDetails.file) {
        try {
          const fileBData = payload.fileDetails.file;
          const uploadedFilePath = await this.fileUtil.saveFile(fileBData, UploadType.JOB_ORDER);
          if (uploadedFilePath) {
            attachmentPath = String(uploadedFilePath);
          }
        } catch (error) {
          console.error("Error uploading file:", error);
          // Continue without file if upload fails (S3 credentials issue)
          // You can uncomment the line below to make file upload required
          // throw new HttpException("Failed to upload file: " + error.message, HttpStatus.INTERNAL_SERVER_ERROR);
        }
      }

      const updateJobOrderDto: UpdateJobOrderDto = {
        jobId: payload.data.jobId,
        clientName: payload.data.clientName,
        clientType: payload.data.clientType,
        jobTitle: payload.data.jobTitle,
        jobDescriptionSummary: payload.data.jobDescriptionSummary,
        workLocationCountry: payload.data.workLocationCountry,
        remoteHybridOnsite: payload.data.remoteHybridOnsite,
        jobStartDate: payload.data.jobStartDate,
        jobEndDate: payload.data.jobEndDate,
        contractType: payload.data.contractType,
        numberOfPositions: payload.data.numberOfPositions
          ? parseInt(payload.data.numberOfPositions)
          : undefined,
        requiredSkills: payload.data.requiredSkills,
        yearsOfExperience: payload.data.yearsOfExperience,
        minEducationalQualification: payload.data.minEducationalQualification,
        salaryCtcRange: payload.data.salaryCtcRange,
        shift: payload.data.shift,
        shiftTiming: payload.data.shiftTiming,
        languageRequirement: payload.data.languageRequirement,
        languageProficiencyLevel: payload.data.languageProficiencyLevel,
        nationalityPreference: payload.data.nationalityPreference,
        visaWorkPermitProvided: payload.data.visaWorkPermitProvided,
        clientSpocName: payload.data.clientSpocName,
        internalRecruiterAssigned: payload.data.internalRecruiterAssigned,
        remarksNotes: payload.data.remarksNotes,
        detailedJdAttachment: attachmentPath,
        jobOwner: payload.data.jobOwner,
        deliveryLead: payload.data.deliveryLead,
        status: payload.data.status,
        updatedBy: payload.data.updatedBy,
      };

      return await this.jobOrderService.update(id, updateJobOrderDto, attachmentPath);
    } catch (error) {
      throw new HttpException(
        error.message || "Failed to update job order",
        error.status || HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Roles('Admin', 'HR Manager')
  @Delete(":id")
  @ApiOperation({ summary: "Delete a job order by ID" })
  @ApiResponse({ status: 200, description: "The job order has been successfully deleted." })
  @ApiResponse({ status: 404, description: "Job order not found" })
  remove(@Param("id") id: string) {
    return this.jobOrderService.remove(id);
  }
}

